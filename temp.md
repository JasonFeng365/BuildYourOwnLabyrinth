For the main menu, most of the functionality already existed within the previous labs and did not require significant debugging. The main challenges of getting the menu system to work included getting letters to dynamically center in username mode. Initially, when inputting the username, the letters would emerge from left to right. This, however, made the screen empty and not as pleasant to look at. To implement the dynamic centering, the main issue was knowing where to erase and update characters since any user input would change the position of every character. We solved this problem by erasing the line entirely and redrawing the entire char array.
Another issue that occurred was the main menu incorrectly changing game states when attempting to play. Whenever a user would attempt to choose a level regardless of whether it was a user or sample level, an additional level select menu would appear urging the user to select a user level. Additionally, levels selected would not be the levels that actually displayed on screen. The cause of our additional menu screen was due to a flag variable that controls the game state changing from gameplay to leaderboard containing a garbage value specifically when attempting to play. The solution to this problem was to initialize the flag variable to zero during setup. The issue of the wrong levels being loaded was due to incorrectly parsing through the AWS shadow data. Not only would the level data be loaded but also the leaderboard data. This was fixed by using a separate variable whose purpose is solely to store level data using `memcpy()`.
One problem encountered regarding gameplay is that there is not enough memory in the LaunchPad to fit a full `128` x `128` grid of pixel colors. The team’s initial plan was to maintain an entire array of pixels for O(1) access, removing the need to recompute each tile’s pixels each frame. Although using a full 128 x 128 grid was not possible, a `128` wide by `97` tall grid was used instead, which was enough to hold every pixel while not exceeding the memory limit. This grid maps to the bottom `97` pixels of the OLED display, and the upper `31` pixels are simply mapped to black.
Regarding communication protocols and sensors, there were no real issues in implementation. The one issue which was swiftly solved (after a day) was Andrew's I2C accelerometer not working. The issue was resolved by changing the onboard jumper configuration- one misplaced jumper was causing the accelerometer to be unable to return data.
By far the most pressing challenge was the collision and rendering engine during gameplay. The team spent 20 hours over a weekend mapping out physics logic, and implemented rendering after many mathematical calculations to determine where items should be rendered on the OLED. This task was made even more difficult with the addition of slopes, which required 10 more hours of calculations to ensure the ball can roll up and down slopes. The team successfully finished the engine to achieve a smooth physics engine and an impressive isomorphic point-of-view.
